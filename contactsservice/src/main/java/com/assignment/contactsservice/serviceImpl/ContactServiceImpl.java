package com.assignment.contactsservice.serviceImpl;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.assignment.contactsservice.event.ContactCreatedEvent;
import com.assignment.contactsservice.model.Contact;
import com.assignment.contactsservice.repository.ContactRepository;
import com.assignment.contactsservice.service.ContactService;

/**
 * Core business logic implementation for contact management.
 * This class handles database interaction, event publishing, and the critical
 * performance-oriented filtering logic.
 */
@Service
public class ContactServiceImpl implements ContactService {

	private static final Logger log = LoggerFactory.getLogger(ContactServiceImpl.class);

	private final ContactRepository contactRepository;
	private final KafkaTemplate<String, ContactCreatedEvent> kafkaTemplate;

	// Constructor Injection
	public ContactServiceImpl(ContactRepository contactRepository,
			KafkaTemplate<String, ContactCreatedEvent> kafkaTemplate) {
		this.contactRepository = contactRepository;
		this.kafkaTemplate = kafkaTemplate;
		log.info("ContactServiceImpl initialized successfully.");
	}

	/**
	 * Creates a new Contact in the database and publishes a ContactCreatedEvent.
	 * 
	 * 
	 * @param contact The validated contact object to be persisted.
	 * @return The Contact object after it has been saved to the database
	 */

	@Override
	public Contact createContact(Contact contact) {
		log.debug("Attempting to save new contact: {}", contact.getName());
		// Save contact record to the 'contacts' table. The ID is generated by the
		// database.
		Contact saved = contactRepository.save(contact);
		log.info("Contact saved to database with ID: {}", saved.getId());

		// Create the event payload using the generated ID and name.
		ContactCreatedEvent event = new ContactCreatedEvent(saved.getId(), saved.getName());

		// Publish event to Kafka topic 'contactevent_topic'
		kafkaTemplate.sendDefault(event);
		log.info("ContactCreatedEvent published for ID: {}", saved.getId());
		return saved;
	}

	/**
	 * Retrieves contacts, excluding those whose name matches the given regex
	 * filter. No SQL filter: Filter is applied in the Java
	 * stream. Large dataset: Uses @Transactional and Stream<Contact> to avoid OOM
	 * by processing data incrementally .
	 * 
	 * @param nameFilter The regular expression to exclude.
	 * @return A List of Contacts that do not match the filter.
	 * @throws PatternSyntaxException If the nameFilter is an invalid regex.
	 */
	@Transactional(readOnly = true) // Essential: keeps DB session open for the stream
	@Override
	public List<Contact> getContactsExcludingRegex(String nameFilter) throws PatternSyntaxException {
		log.info("Starting contact filtering process. Exclusion Pattern: '{}'", nameFilter);

		// Validate the regex syntax. If invalid, it throws a PatternSyntaxException,
		// which the Controller will catch to return the 400 BAD_REQUEST.
		Pattern exclusionPattern = Pattern.compile(nameFilter.trim());
		log.debug("Regex pattern compiled successfully.");

		// Efficient Data Retrieval and Java-side Filtering
		// Use try-with-resources to ensure the underlying database connection/cursor is
		// closed.
		try (Stream<Contact> contactStream = contactRepository.streamAllContacts()) {

			// Process the stream, applying the filter in Java code.
			List<Contact> filteredContacts = contactStream
					// Use parallel processing for faster regex matching on large datasets.
					.parallel()
					// Filter: Keep the contact IF its name does NOT match the exclusion pattern.
					.filter(contact -> {
						// Add defensive check for null name
						return contact.getName() != null && !exclusionPattern.matcher(contact.getName()).matches();
					})
					.collect(Collectors.toList());

			log.info("Filtering complete. Returned {} contacts from the stream.", filteredContacts.size());
			return filteredContacts;

		} // Stream is automatically closed here, releasing the database cursor.

	}

}
