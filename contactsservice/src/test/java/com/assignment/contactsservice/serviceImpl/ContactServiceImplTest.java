package com.assignment.contactsservice.serviceImpl;

import com.assignment.contactsservice.event.ContactCreatedEvent;
import com.assignment.contactsservice.model.Contact;
import com.assignment.contactsservice.repository.ContactRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Unit tests for the ContactServiceImpl class.
 * Uses Mockito to verify business logic and interactions with dependencies (Repository and Kafka).
 */
@ExtendWith(MockitoExtension.class)
class ContactServiceImplTest {

    private static final Logger log = LoggerFactory.getLogger(ContactServiceImplTest.class);

    // Mocks the dependencies of the service
    @Mock
    private ContactRepository contactRepository;

    @Mock
    private KafkaTemplate<String, ContactCreatedEvent> kafkaTemplate;

    // Injects the mocks into the service instance being tested
    @InjectMocks
    private ContactServiceImpl contactService;

    private Contact contactRequest;
    private List<Contact> sampleContacts;

    @BeforeEach
    void setUp() {
        // Setup a contact object used for creation tests 
        contactRequest = new Contact(null, "TestName");
        
        // Setup a sample dataset for filtering tests
        sampleContacts = Arrays.asList(
            new Contact(1L, "Alice"),
            new Contact(2L, "Bob"),
            new Contact(3L, "Charlie"),
            new Contact(4L, "Dave")
        );
        log.info("Test setup complete. Sample data initialized.");
    }


    /**
     * Tests the core flow of creating a contact: saving to DB and publishing an event.
     */
    @Test
    void createContact_SavesAndPublishesEvent() {
        log.info("Running test: createContact_SavesAndPublishesEvent");
        
        //  Define the contact the repository should "return" after saving (with a generated ID)
        Contact savedContact = new Contact(10L, "TestName");
        when(contactRepository.save(any(Contact.class))).thenReturn(savedContact);

        // Act
        Contact result = contactService.createContact(contactRequest);

        // Assert
        assertNotNull(result, "The returned contact should not be null.");
        assertEquals(10L, result.getId(), "The returned contact must have the ID generated by the repository.");
        
        // Verify 1: Database save was called exactly once with the input object
        verify(contactRepository, times(1)).save(contactRequest);

        // Verify 2: Kafka event publishing was called exactly once
        verify(kafkaTemplate, times(1)).sendDefault(any(ContactCreatedEvent.class));
        
        log.info("Test passed: Contact saved and event publishing verified.");
    }


    /**
     * Tests the Java-side filtering logic to ensure non-matching contacts are returned.
     */
    @Test
    void getContactsExcludingRegex_FiltersOutMatchingContacts() {
        log.info("Running test: getContactsExcludingRegex_FiltersOutMatchingContacts");
        
        // Arrange: Filter out names starting with 'B' (i.e., Bob)
        String regexFilter = "^B.*"; 
        
        // Mock the repository to return the stream of sample contacts
        when(contactRepository.streamAllContacts()).thenReturn(sampleContacts.stream());

        // Act
        List<Contact> filteredList = contactService.getContactsExcludingRegex(regexFilter);

        // Assert
        assertEquals(3, filteredList.size(), "The list should contain 3 contacts (Bob excluded).");
        // Ensure 'Bob' is absent
        assertTrue(filteredList.stream().noneMatch(c -> c.getName().equals("Bob")), "Contact 'Bob' must be excluded."); 
        // Ensure others are present
        assertTrue(filteredList.stream().anyMatch(c -> c.getName().equals("Alice")), "Contact 'Alice' must be included."); 
        
        // Verify the repository streaming method was called once
        verify(contactRepository, times(1)).streamAllContacts();
        log.info("Test passed: Filtering logic confirmed.");
    }
    
    /**
     * Tests that all contacts are returned when the filter regex matches nothing.
     */
    @Test
    void getContactsExcludingRegex_ReturnsAllIfFilterDoesNotMatch() {
        log.info("Running test: getContactsExcludingRegex_ReturnsAllIfFilterDoesNotMatch");
        
        // Arrange: Filter for names starting with 'Z' (none match)
        String regexFilter = "^Z.*"; 
        when(contactRepository.streamAllContacts()).thenReturn(sampleContacts.stream());

        // Act
        List<Contact> filteredList = contactService.getContactsExcludingRegex(regexFilter);

        // Assert
        assertEquals(4, filteredList.size(), "All 4 contacts should be returned.");
        
        // Verify the repository streaming method was called once
        verify(contactRepository, times(1)).streamAllContacts();
        log.info("Test passed: No filtering applied confirmed.");
    }

    /**
     * Tests the mandatory error handling for an invalid regular expression.
     */
    @Test
    void getContactsExcludingRegex_ThrowsPatternSyntaxExceptionForInvalidRegex() {
        log.info("Running test: getContactsExcludingRegex_ThrowsPatternSyntaxExceptionForInvalidRegex");
        
        // Arrange: Invalid regex syntax
        String invalidRegex = "["; 

        // Act & Assert
        // The service method must throw PatternSyntaxException when trying to compile the invalid pattern
        assertThrows(PatternSyntaxException.class, () -> {
            contactService.getContactsExcludingRegex(invalidRegex);
        }, "Should throw PatternSyntaxException for invalid regex.");
        
        // Verify the repository method was NOT called, as the error happens immediately upon compilation
        verify(contactRepository, never()).streamAllContacts();
        log.info("Test passed: PatternSyntaxException handling confirmed.");
    }
    
    /**
     * Tests that an empty list is returned gracefully when the database is empty.
     */
    @Test
    void getContactsExcludingRegex_HandlesEmptyDatabaseStream() {
        log.info("Running test: getContactsExcludingRegex_HandlesEmptyDatabaseStream");
        
        // Arrange: An irrelevant regex filter
        String regexFilter = ".*"; 
        // Mock the repository to return an empty stream
        when(contactRepository.streamAllContacts()).thenReturn(Stream.empty());

        // Act
        List<Contact> filteredList = contactService.getContactsExcludingRegex(regexFilter);

        // Assert
        assertTrue(filteredList.isEmpty(), "The returned list must be empty.");
        assertEquals(0, filteredList.size());
        
        log.info("Test passed: Empty stream handling confirmed.");
    }
}
